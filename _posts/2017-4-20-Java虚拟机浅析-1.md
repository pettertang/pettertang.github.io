---
layout: post_layout
title: Java虚拟机浅析-1
time: 2017年4月20日 星期四
location: 北京
pulished: true
excerpt_separator: "**此内存区域是唯一一个"
---  
**Java虚拟机浅析(一)**　　**2017年4月20日**　　**天气：晴**    

**1.JVM运行时数据区**  
　　Java虚拟机管理的内存包括几个运行时数据内存：方法区、虚拟机栈、本地方法栈、堆、程序计数器，其中方法区和堆是由线程共享的数据区，其他几个是线程隔离的数据区。如下图所示：  
<img src = "/blog/2.png">   
**(1)程序计数器**  
　　程序计数器是一块较小的内存，他可以看做是当前线程所执行的行号指示器。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码的指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个**Java方法**，这个计数器记录的是正在执行的虚拟机**字节码指令的地址**；如果正在执行的是**Native方法**，这个计数器则**为空**。**此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemotyError情况的区域**。  
**(2)Java虚拟机栈**  
　　虚拟机栈描述的是Java方法执行的内存模型：**每个方法在执行的同时都会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息**。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  
　　**栈内存就是虚拟机栈，或者说是虚拟机栈中局部变量表的部分**。  
　　局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（refrence）类型和returnAddress类型（指向了一条字节码指令的地址）。  
　　其中64位长度的long和double类型的数据会占用两个局部变量空间，其余的数据类型只占用1个。  
　　Java虚拟机规范对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机扩展时无法申请到足够的内存，就会跑出OutOfMemoryError异常。  
**(3)本地方法栈**  
　　本地方法栈和虚拟机栈发挥的作用是非常类似的，他们的区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。  
　　本地方法栈区域也会抛出StackOverflowError和OutOfMemoryErroy异常。  
**(4)Java堆**  
　　堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建，此内存区域的唯一目的是**存放对象实例**，几乎所有的对象实例都在这里分配内存。**所有的对象实例和数组都在堆上分配**。  
　　Java堆是垃圾收集器管理的主要区域。Java堆细分为**新生代**和**老年代**。不管怎样，划分的目的都是为了更好的回收内存，或者更快地分配内存。  
　　Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有完成实例分配，并且堆也无法在扩展时将会抛出OutOfMemoryError异常。  
如下图所示：  
<img src = "/blog/3.png">  
1)堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行**加锁**，这也导致了new对象的开销是比较大的。  
2)Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配。  
3)TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。  
4)所有新创建的Object 都将会存储在新生代Yong Generation中。如果Young Generation的数据在一次或多次GC后存活下来，那么将被转移到OldGeneration。**新的Object总是创建在Eden  Space**。  
**(5)方法区**  
　　方法区它用于储存已被虚拟机加载的**类信息、常量、静态变量、即时编译器编译后的代码等数据**。  
　　除了像Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。**这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载**。  
　　当方法区无法满足内存分配需求时，将抛出OutOfMemoryErroy异常。  
**(6)运行时常量池**   
　　它是**方法区的一部分**。Class文件中除了有关的版本、字段、方法、接口等描述信息外、还有一项信息是常量池，**用于存放编译期生成的各种字面量和符号引用**，这部分内容将在类加载后进入方法区的运行时常量池中存放。  
　　Java语言并不要求常量一定只有编译期才能产生，也就是**可能将新的常量放入池中**，这种特性被开发人员利用得比较多的便是**String类的intern()方法**。  
　　当常量池无法再申请到内存时会抛出OutOfMemoryError异常。  

---  
**2.hotspot虚拟机对象**  
**2.1对象的创建**  
**(1)检查**    
　　虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。  
**(2)分配内存**  
　　接下来将为新生对象分配内存，为对象分配内存空间的任务等同于把一块确定的大小的内存从Java堆中划分出来。  
　　假设Java堆中内存是绝对规整的，所有用过的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针指向空闲空间那边挪动一段与对象大小相等的距离，这个分配方式叫做“指针碰撞”。  
　　如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式成为“空闲列表”。  
　　选择那种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。  
**(3)Init**  
　　执行new指令之后会接着执行Init方法，进行初始化，这样一个对象才算产生出来。  
**2.2对象的内存布局**  
　　在HotSpot虚拟机中，对象在内存中储存的布局可以分为3块区域：对象头、实例数据和对齐填充。  
对象头包括两部分：  
a)储存对象自身的运行时数据，如哈希码、GC分带年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳；  
b)另一部分是指类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。  
**2.3对象的访问定位**  
**(1)使用句柄访问**  
　　Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址。  
　　优势:reference中存储的是稳点的句柄地址,在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改。  
**(2)使用直接指针访问**  
　　Java堆对象的布局就必须考虑如何访问类型数据的相关信息,而refreence中存储的直接就是对象的地址。  
　　优势：速度更快，节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。  

---
**3.OutOfMemoryError 异常**  
**(1)Java堆溢出**  
　　Java堆用于存储对象实例，只要不断的创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在数量到达最大堆的容量限制后就会产生内存溢出异常。  
　　如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。  
　　如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。  
**(2)虚拟机栈和本地方法栈溢出**  
　　对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：  
如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError；  
如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。  
　　在单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。  
　　如果是多线程导致的内存溢出，与栈空间是否足够大并不存在任何联系，这个时候每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。解决的时候是在不能减少线程数或更换64为的虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。  
**(3)方法区和运行时常量池溢出**  
　　String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。  
　　由于常量池分配在永久代中，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。  

---
**4.垃圾收集**   
程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。我们说的垃圾回收通常指的是Java堆的垃圾回收。  

**4.1对象在JVM堆区的状态**   
如下图所示：  
<img src = "/blog/4.png">   
**1)**可触及状态：程序中还有变量引用，那么此对象为可触及状态。  
**2)**可复活状态：当程序中已经没有变量引用这个对象，那么此对象由可触及状态转为可复活状态。CG线程将在一定的时间准备调用此对象的finalize方法（finalize方法继承或重写子Object），finalize方法内的代码有可能将对象转为可触及状态，否则对象转化为不可触及状态。  
**3)**不可触及状态：只有当对象处于不可触及状态时，GC线程才能回收此对象的内存。     

**4.2判断对象存活**  
**(1)引用计数器法**  
　　给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。  
**(2)可达性分析算法**  
　　通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的。  
Java语言中GC Roots的对象包括下面几种：  
**a)**虚拟机栈（栈帧中的本地变量表）中引用的对象  
**b)**方法区中类静态属性引用的对象  
**c)**方法区中常量引用的对象  
**d)**本地方法栈JNI（Native方法）引用的对象  

**4.3引用**  
　　强引用就是在程序代码之中普遍存在的，类似Object obj = new Object() 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。  
　　软引用用来描述一些还有用但并非必须的元素。对于它在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存才会抛出内存溢出异常。  
　　弱引用用来描述非必须对象的，但是它的强度比软引用更弱一些，被引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够都会回收掉只被弱引用关联的对象。  
　　虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。  

**4.4finalize()方法**   
　　在JVM垃圾回收器收集一个对象之前，一般要求程序调用适当的方法释放资源，但在没有明确释放资源的情况下，Java提供了缺省机制来终止该对象心释放资源，这个方法就是finalize()。它的原型为：
```Java
protected void finalize() throws Throwable
```
在finalize()方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。  
　　之所以要使用finalize()，是存在着垃圾回收器不能处理的特殊情况。例如：  
**1)**由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。  
**2)**又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。  

**4.5回收方法区**  
永久代的垃圾收集主要回收两部分内容：**废弃常量和无用的类**。  
**废弃常量**：假如一个字符串abc已经进入了常量池中，如果当前系统没有任何一个String对象abc，也就是没有任何Stirng对象引用常量池的abc常量，也没有其他地方引用的这个字面量，这个时候发生内存回收这个常量就会被清理出常量池。  
**无用的类**：  
**a)**该类所有的实例都已经被回收，就是Java堆中不存在该类的任何实例  
**b)**加载该类的ClassLoader已经被回收  
**c)**该类对用的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法  

**4.6垃圾收集算法**  
**(1)标记—清除算法(Mark-Sweep)**  
标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。具体过程如下图所示：  
<img src = "/blog/5.png">  
不足：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。  
**(2)复制算法(Copying)**  
它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示：  
<img src = "/blog/6.png">  
不足：将内存缩小为了原来的一半。  
实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为**一块较大的Eden空间和两块较小的Survivor空间**，每次使用Eden和其中一块Survivor。  
当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。  
**(3)标记-整理算法(Mark-Compact)**  
该算法标记阶段和标记清除算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示： 
<img src = "/blog/7.png">  
**(4)分代收集算法**  
　　分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。  
　　目前大部分垃圾收集器**对于新生代都采取Copying算法**，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。  
　　而由于老年代的特点是每次回收都只回收少量对象，一般使用的是**Mark-Compact**算法。  
如下图所示：  
<img src = "/blog/8.png">   
**新年代**：新创建的对象都存放在这里。因为大多数对象很快变得不可达，所以大多数对象在年轻代中创建，然后消失。当对象从这块内存区域消失时，我们说发生了一次“**minor GC**”。  
**老年代**：没有变得不可达，存活下来的年轻代对象被复制到这里。这块内存区域一般大于年轻代。因为它更大的规模，GC发生的次数比在年轻代的少。对象从老年代消失时，我们说“**major GC**”（或“**full GC**”）发生了。  
上图中的**永久代(permanent generation)**也称为“**方法区(method area)**”，他存储class对象和字符串常量。所以这块内存区域绝对不是永久的存放从老年代存活下来的对象的。在这块内存中有可能发生垃圾回收。发生在这里垃圾回收也被称为**major GC**。 

**4.7垃圾收集器**
**a)Serial收集器**:  
这个收集器是一个单线程的收集器，但它的单线程的意义不仅仅说明它会只使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。  
**b)ParNew 收集器**：  
Serial收集器的多线程版本，除了使用了多线程进行收集之外，其余行为和Serial收集器一样。  
并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。  
并发：指用户线程与垃圾收集线程同时执行（不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行于另一个CPU上。  
**c)Parallel Scavenge**：  
该收集器是一个新生代收集器，它是使用复制算法的收集器，又是并行的多线程收集器。  
**d)Serial Old 收集器**：  
是Serial收集器的老年代版本,是一个单线程收集器，使用标记整理算法。  
**e)Parallel Old 收集器**：  
Parallel Old是Paraller Seavenge收集器的老年代版本，使用多线程和标记整理算法。  
**f)CMS收集器**：  
CMS收集器是基于标记清除算法实现的，整个过程分为4个步骤：  
1.初始标记　2.并发标记　3.重新标记　4.并发清除  
优点：并发收集、低停顿  
缺点：  
1.CMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/4  
2.CMS收集器无法处理浮动垃圾，可能出现Failure失败而导致一次Full G场地产生  
3.CMS是基于标记清除算法实现的  
**g)G1收集器**：  
它是一款面向服务器应用的垃圾收集器  
1.并行与并发：利用多CPU缩短STOP-The-World停顿的时间  
2.分代收集  
3.空间整合：不会产生内存碎片  
4.可预测的停顿  
运作方式：初始标记，并发标记，最终标记，筛选回收  

**4.8内存分配与回收策略**  
**4.8.1对象优先在Eden分配**：  
大多数情况对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。  
**4.8.2大对象直接进入老年代**：  
所谓大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。这样做的目的是避免Eden区及两个Servivor之间发生大量的内存复制。  
**4.8.3长期存活的对象将进入老年代**：  
如果对象在Eden区出生并且尽力过一次Minor GC后仍然存活，并且能够被Servivor容纳，将被移动到Servivor空间中，并且把对象年龄设置成为1.对象在Servivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋级到老年代中。  
**4.8.4动态对象年龄判定**：  
为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋级到老年代，如果在Servivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代，无须等到MaxTenuringThreshold中要求的年龄。  
**4.8.5空间分配担保**：  
在发生Minor GC 之前，虚拟机会检查老年代最大可 用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许那么会继续检查老年代最大可用的连续空间是否大于晋级到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC 是有风险的：如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。  



